require('dotenv').config({ path: '.env.local' });
const mysql = require('mysql2/promise');

const dbConfig = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  port: parseInt(process.env.DB_PORT || '3306')
};

async function ultimateCleanup() {
  let connection;
  
  try {
    console.log('üîó ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...');
    connection = await mysql.createConnection(dbConfig);
    
    // ‡∏´‡∏¢‡∏∏‡∏î background processes ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô
    console.log('\nüõë ‡∏´‡∏¢‡∏∏‡∏î background sync processes...');
    try {
      await fetch('http://localhost:3000/api/sync/realtime', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'stop' })
      });
      
      await fetch('http://localhost:3000/api/smart-auto', {
        method: 'POST', 
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'disable' })
      });
      
      console.log('‚úÖ ‡∏´‡∏¢‡∏∏‡∏î background processes ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    } catch (error) {
      console.log('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏¢‡∏∏‡∏î API ‡πÑ‡∏î‡πâ - ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠');
    }
    
    console.log('\n‚è≥ ‡∏£‡∏≠ 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÉ‡∏´‡πâ processes ‡∏´‡∏¢‡∏∏‡∏î‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå...');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    const tableName = 'aoy';
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î
    const [beforeCount] = await connection.execute(`SELECT COUNT(*) as count FROM \`${tableName}\``);
    console.log(`\nüìä ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î: ${beforeCount[0].count} ‡πÅ‡∏ñ‡∏ß`);
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥
    const [duplicates] = await connection.execute(`
      SELECT sheet_row_index, COUNT(*) as count 
      FROM \`${tableName}\`
      WHERE sheet_row_index IS NOT NULL
      GROUP BY sheet_row_index
      ORDER BY sheet_row_index
    `);
    
    console.log('\nüîç ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á sheet_row_index:');
    for (const dup of duplicates) {
      const status = dup.count > 1 ? '‚ùå ‡∏ã‡πâ‡∏≥' : '‚úÖ';
      console.log(`   ‡πÅ‡∏ñ‡∏ß ${dup.sheet_row_index}: ${dup.count} records ${status}`);
    }
    
    // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    console.log('\nüóëÔ∏è ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (TRUNCATE)...');
    await connection.execute(`TRUNCATE TABLE \`${tableName}\``);
    console.log('‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Google Sheets
    console.log('\nüìÑ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Google Sheets...');
    
    // ‡∏≠‡πà‡∏≤‡∏ô config ‡∏à‡∏≤‡∏Å database
    const [configs] = await connection.execute(`
      SELECT id, name, table_name, sheet_url, sheet_name 
      FROM sync_configs 
      WHERE table_name = ? AND is_active = 1
    `, [tableName]);
    
    if (configs.length === 0) {
      console.log('‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö config ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á', tableName);
      return;
    }
    
    const config = configs[0];
    
    // Setup Google Sheets API
    const { google } = require('googleapis');
    const sheets = google.sheets('v4');
    
    // ‡∏≠‡πà‡∏≤‡∏ô service account credentials
    const credentials = require('./credentials.json');
    const auth = new google.auth.GoogleAuth({
      credentials,
      scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly']
    });
    
    const authClient = await auth.getClient();
    google.options({ auth: authClient });
    
    // ‡πÅ‡∏¢‡∏Å spreadsheet ID ‡∏à‡∏≤‡∏Å URL
    const urlMatch = config.sheet_url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
    if (!urlMatch) {
      console.log('‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏¢‡∏Å spreadsheet ID ‡∏à‡∏≤‡∏Å URL ‡πÑ‡∏î‡πâ');
      return;
    }
    const spreadsheetId = urlMatch[1];
    
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: spreadsheetId,
      range: config.sheet_name,
    });
    
    const sheetData = response.data.values || [];
    const dataRows = sheetData.slice(1).filter(row => row.some(cell => cell && cell.trim())); // ‡∏Ç‡πâ‡∏≤‡∏° header ‡πÅ‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß‡∏ß‡πà‡∏≤‡∏á
    
    console.log(`üìä ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ${dataRows.length} ‡πÅ‡∏ñ‡∏ß‡πÉ‡∏ô Google Sheets`);
    
    if (dataRows.length === 0) {
      console.log('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Google Sheets');
      return;
    }
    
    // Insert ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏° tracking columns
    console.log('\nüìù Insert ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏° tracking columns...');
    
    for (let i = 0; i < dataRows.length; i++) {
      const row = dataRows[i];
      const sheetRowIndex = i + 2; // Google Sheets row (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 2)
      
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á row_hash
      const crypto = require('crypto');
      const rowString = row.join('|');
      const rowHash = crypto.createHash('md5').update(rowString).digest('hex');
      
      const name = row[0] || null;
      const date = row[1] || null;
      const mess = row[2] || null;
      
      await connection.execute(`
        INSERT INTO \`${tableName}\` (name, date, mess, sheet_row_index, row_hash, synced_at)
        VALUES (?, ?, ?, ?, ?, NOW())
      `, [name, date, mess, sheetRowIndex, rowHash]);
      
      console.log(`   ‚úÖ Insert ‡πÅ‡∏ñ‡∏ß ${sheetRowIndex}: "${name}" | "${date}" | "${mess}"`);
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
    const [afterCount] = await connection.execute(`SELECT COUNT(*) as count FROM \`${tableName}\``);
    console.log(`\nüìä ‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î: ${afterCount[0].count} ‡πÅ‡∏ñ‡∏ß`);
    
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó sync_configs
    await connection.execute(`
      UPDATE sync_configs 
      SET row_count = ?, last_sync_at = NOW()
      WHERE table_name = ?
    `, [dataRows.length, tableName]);
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° sync log
    await connection.execute(`
      INSERT INTO sync_logs (config_id, status, message, created_at)
      SELECT id, 'success', 'ULTIMATE cleanup: fresh sync (? rows)', NOW()
      FROM sync_configs WHERE table_name = ?
    `, [dataRows.length, tableName]);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ duplicates
    const [finalCheck] = await connection.execute(`
      SELECT sheet_row_index, COUNT(*) as count 
      FROM \`${tableName}\`
      GROUP BY sheet_row_index
      HAVING COUNT(*) > 1
    `);
    
    if (finalCheck.length === 0) {
      console.log('\nüéâ ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥');
    } else {
      console.log('\n‚ö†Ô∏è ‡∏¢‡∏±‡∏á‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥:');
      for (const dup of finalCheck) {
        console.log(`   ‡πÅ‡∏ñ‡∏ß ${dup.sheet_row_index}: ${dup.count} records`);
      }
    }
    
    console.log('\n‚úÖ ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!');
    console.log('üí° ‡πÉ‡∏ä‡πâ node debug-sync.js ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå');
    
  } catch (error) {
    console.error('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:', error.message);
    process.exit(1);
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

ultimateCleanup();
