// stop-and-clean.js - ‡∏´‡∏¢‡∏∏‡∏î Real-time Sync ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏≥ Deep Clean
require('dotenv').config({ path: '.env.local' });
const mysql = require('mysql2/promise');
const { google } = require('googleapis');

async function stopAndClean() {
  let connection;
  try {
    console.log('üõë Step 1: STOPPING all background sync processes...\n');

    // ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏´‡∏¢‡∏∏‡∏î Real-time Sync ‡∏ú‡πà‡∏≤‡∏ô API (‡∏ñ‡πâ‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà)
    try {
      const response = await fetch('http://localhost:3001/api/sync/realtime', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'stop' })
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('‚úÖ Real-time Sync stopped via API:', result.message);
      }
    } catch (fetchError) {
      console.log('‚ö†Ô∏è  Cannot reach API (server might be down) - proceeding with direct database cleanup');
    }

    // ‡∏´‡∏¢‡∏∏‡∏î Smart Auto-Pilot
    try {
      const smartResponse = await fetch('http://localhost:3001/api/smart-auto', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'disable' })
      });
      
      if (smartResponse.ok) {
        const smartResult = await smartResponse.json();
        console.log('‚úÖ Smart Auto-Pilot stopped via API:', smartResult.message);
      }
    } catch (fetchError) {
      console.log('‚ö†Ô∏è  Cannot reach Smart Auto-Pilot API');
    }

    console.log('\n‚è≥ Waiting 3 seconds for background processes to stop...');
    await new Promise(resolve => setTimeout(resolve, 3000));

    console.log('\nüßπ Step 2: DEEP CLEANING database...\n');

    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ database
    connection = await mysql.createConnection({
      host: process.env.DB_HOST || 'localhost',
      user: process.env.DB_USER || 'root',
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'sheets_sync'
    });

    // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ sync configs
    const [configs] = await connection.execute(`
      SELECT id, name, table_name, sheet_url, sheet_name, columns
      FROM sync_configs 
      WHERE is_active = 1
    `);

    for (const config of configs) {
      console.log(`üßπ Deep Cleaning Table: ${config.table_name}`);
      console.log(`üìã Config: ${config.name}`);
      
      // ‡∏ô‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏ö
      const [beforeCount] = await connection.execute(`
        SELECT COUNT(*) as count FROM \`${config.table_name}\`
      `);
      console.log(`üìä Rows before cleaning: ${beforeCount[0].count}`);

      // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á (‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥)
      console.log('üóëÔ∏è  FORCE DELETING all existing data...');
      await connection.execute(`TRUNCATE TABLE \`${config.table_name}\``);
      console.log('‚úÖ All data completely removed');

      // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets
      console.log('üìÑ Fetching fresh data from Google Sheets...');
      
      const auth = new google.auth.GoogleAuth({
        keyFile: './credentials.json',
        scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly']
      });

      const sheets = google.sheets({ version: 'v4', auth });
      const spreadsheetId = extractSpreadsheetId(config.sheet_url);
      
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: spreadsheetId,
        range: config.sheet_name,
      });

      const sheetData = response.data.values || [];
      if (sheetData.length === 0) {
        console.log('‚ö†Ô∏è  No data in Google Sheets');
        continue;
      }

      const headers = sheetData[0];
      const dataRows = sheetData.slice(1); // ‡∏•‡∏ö header row
      
      console.log(`üìä Found ${dataRows.length} data rows in Google Sheets`);

      if (dataRows.length === 0) {
        console.log('‚ö†Ô∏è  No data rows to sync');
        continue;
      }

      // ‡πÅ‡∏õ‡∏•‡∏á column mappings
      const columnMappings = JSON.parse(config.columns);
      const mappingArray = Object.entries(columnMappings).map(([googleCol, mysqlCol]) => ({
        googleColumn: googleCol,
        mysqlColumn: mysqlCol
      }));

      // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏° tracking
      const columns = mappingArray.map(m => m.mysqlColumn);
      const safeColumns = columns.map(col => `\`${col}\``);
      const placeholders = columns.map(() => '?').join(', ');
      
      const insertSQL = `
        INSERT INTO \`${config.table_name}\` (${safeColumns.join(', ')}, sheet_row_index, row_hash)
        VALUES (${placeholders}, ?, ?)
      `;

      console.log('üìù Inserting fresh data with proper tracking...');
      let insertedCount = 0;

      for (const [index, row] of dataRows.entries()) {
        const sheetRowIndex = index + 2; // +2 ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ header = row 1, data ‡πÄ‡∏£‡∏¥‡πà‡∏° row 2
        
        // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        const values = columns.map(col => {
          const mapping = mappingArray.find(m => m.mysqlColumn === col);
          if (!mapping) return null;
          
          const headerIndex = headers.findIndex(h => h === mapping.googleColumn);
          if (headerIndex === -1 || headerIndex >= row.length) return null;
          
          const value = row[headerIndex];
          return (value !== undefined && value !== null && value !== '') ? String(value).trim() : null;
        });

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á hash
        const normalizedValues = values.map(val => {
          if (val === null || val === undefined) return '';
          return String(val).trim();
        });
        const rowHash = createRowHash(normalizedValues);

        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        await connection.execute(insertSQL, [...values, sheetRowIndex, rowHash]);
        insertedCount++;
      }

      // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ sync config
      await connection.execute(`
        UPDATE sync_configs 
        SET last_sync_at = CURRENT_TIMESTAMP, row_count = ?
        WHERE id = ?
      `, [insertedCount, config.id]);

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å log
      await connection.execute(`
        INSERT INTO sync_logs (config_id, status, message, rows_synced)
        VALUES (?, 'success', ?, ?)
      `, [config.id, `FINAL clean sync: ${insertedCount} rows (no duplicates)`, insertedCount]);

      console.log(`‚úÖ Successfully synced ${insertedCount} rows`);
      console.log(`üéØ Database now EXACTLY matches Google Sheets\n`);
    }

    console.log('üéâ FINAL CLEANUP COMPLETED!');
    console.log('üîí Background sync processes have been stopped');
    console.log('üìä Database now contains ONLY Google Sheets data');
    console.log('üí° Run debug-sync.js to verify - should show exact match now');

  } catch (error) {
    console.error('‚ùå Error in stop and clean:', error);
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

// Helper functions
function extractSpreadsheetId(url) {
  const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
  return match ? match[1] : null;
}

function createRowHash(data) {
  const crypto = require('crypto');
  const rowString = data.join('|');
  return crypto.createHash('md5').update(rowString, 'utf8').digest('hex');
}

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ
stopAndClean().catch(console.error);
