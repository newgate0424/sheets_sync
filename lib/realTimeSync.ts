import cron from 'node-cron';
import syncService from './syncService';
import smartDeltaSyncService from './smartDeltaSyncService';

class RealTimeSyncManager {
  private syncJobs: Map<number, cron.ScheduledTask> = new Map();
  private isInitialized = false;
  private pollingJobs: Map<number, NodeJS.Timeout> = new Map();
  private useSmartSync = true; // üöÄ Smart Auto-Pilot ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô

  // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö real-time sync
  async initialize() {
    if (this.isInitialized) return;

    console.log('üöÄ Initializing Smart Auto-Pilot Sync Manager...');
    console.log(`üß† Smart Delta Sync Mode: ${this.useSmartSync ? 'ENABLED' : 'DISABLED'}`);
    
    try {
      // ‡∏î‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà active ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á sync jobs
      const configs = await syncService.getAllSyncConfigs();
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ config ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      const validConfigs = configs.filter(config => {
        try {
          const columns = typeof config.columns === 'string' 
            ? JSON.parse(config.columns) 
            : config.columns;
          
          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ columns ‡πÄ‡∏õ‡πá‡∏ô object ‡∏õ‡∏Å‡∏ï‡∏¥ ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà string array
          if (typeof columns !== 'object' || Array.isArray(columns)) {
            console.warn(`Invalid columns format for config ${config.id}: ${config.name}`);
            return false;
          }

          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ key ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏∞‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
          const keys = Object.keys(columns);
          const hasInvalidKeys = keys.some(key => 
            key.includes('{') || key.includes('"') || key.includes(':') || 
            key.includes(',') || key.includes('}') || key.length < 2
          );

          if (hasInvalidKeys) {
            console.warn(`Invalid column keys for config ${config.id}: ${config.name}`, keys);
            return false;
          }

          return true;
        } catch (error) {
          console.warn(`Error validating config ${config.id}:`, error);
          return false;
        }
      });

      console.log(`Found ${configs.length} total configs, ${validConfigs.length} are valid`);

      if (validConfigs.length === 0) {
        console.log('No valid sync configurations found. Real-time sync will not start.');
        this.isInitialized = true;
        return;
      }

      for (const config of validConfigs) {
        this.startSyncJob(config.id, '30s'); // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
      }

      this.isInitialized = true;
      console.log(`Started ${validConfigs.length} sync jobs`);
    } catch (error) {
      console.error('Error initializing real-time sync:', error);
      this.isInitialized = true; // Mark as initialized to prevent repeated attempts
    }
  }

  // ‡πÄ‡∏£‡∏¥‡πà‡∏° sync job ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö config ‡πÄ‡∏â‡∏û‡∏≤‡∏∞
  startSyncJob(configId: number, interval: string = '120s') { // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å 30s ‡πÄ‡∏õ‡πá‡∏ô 120s (2 ‡∏ô‡∏≤‡∏ó‡∏µ)
    // ‡∏´‡∏¢‡∏∏‡∏î job ‡πÄ‡∏Å‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    this.stopSyncJob(configId);

    if (interval.endsWith('s')) {
      // ‡πÉ‡∏ä‡πâ polling ‡πÅ‡∏ó‡∏ô cron ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö interval ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
      const seconds = parseInt(interval.replace('s', ''));
      const pollingInterval = setInterval(async () => {
        await this.performSync(configId);
      }, seconds * 1000);

      this.pollingJobs.set(configId, pollingInterval);
      console.log(`Started polling sync job for config ${configId} with interval ${interval}`);
    } else {
      // ‡πÉ‡∏ä‡πâ cron ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö interval ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
      const job = cron.schedule(interval, async () => {
        await this.performSync(configId);
      }, {
        scheduled: false
      });

      this.syncJobs.set(configId, job);
      job.start();
      console.log(`Started cron sync job for config ${configId} with interval ${interval}`);
    }
  }

  private async performSync(configId: number) {
    try {
      if (this.useSmartSync) {
        // üß† ‡πÉ‡∏ä‡πâ Smart Delta Sync
        console.log(`[${new Date().toISOString()}] Polling config ${configId}...`);
        const result = await smartDeltaSyncService.smartSync(configId);
        
        if (result.success) {
          const stats = result.stats;
          if (stats.newRows > 0 || stats.changedRows > 0) {
            console.log(`[Config ${configId}] Smart sync completed: ${stats.newRows} new, ${stats.changedRows} changed, ${stats.unchangedRows} unchanged (${stats.performance.totalDuration}ms)`);
          } else {
            console.log(`[Config ${configId}] Smart sync - no changes detected (${stats.unchangedRows} unchanged)`);
          }
        } else {
          console.error(`[Config ${configId}] Smart sync error:`, result.message);
          // Fallback to standard sync if smart sync fails
          console.log(`[Config ${configId}] Falling back to standard sync...`);
          const fallbackResult = await syncService.syncData(configId);
          if (fallbackResult.success) {
            console.log(`[Config ${configId}] Fallback sync completed: ${fallbackResult.message}`);
          }
        }
      } else {
        // üìä ‡πÉ‡∏ä‡πâ Standard Incremental Sync
        console.log(`[${new Date().toISOString()}] Starting incremental sync for config ${configId}...`);
        const result = await syncService.syncData(configId);
        
        if (result.success && result.rowsSynced > 0) {
          console.log(`[Config ${configId}] Incremental sync completed: ${result.message} (${result.rowsSynced} rows affected)`);
        } else if (result.success) {
          console.log(`[Config ${configId}] Incremental sync - no changes detected`);
        }
        
        if (!result.success) {
          console.error(`Incremental sync error for config ${configId}:`, result.message);
        }
      }
    } catch (error) {
      console.error(`Error in sync job ${configId}:`, error);
      // Fallback ‡∏ñ‡πâ‡∏≤ Smart Sync error
      if (this.useSmartSync) {
        try {
          console.log(`[Config ${configId}] Smart sync failed, trying standard sync...`);
          const fallbackResult = await syncService.syncData(configId);
          if (fallbackResult.success) {
            console.log(`[Config ${configId}] Fallback standard sync completed`);
          }
        } catch (fallbackError) {
          console.error(`[Config ${configId}] Both smart and standard sync failed:`, fallbackError);
        }
      }
    }
  }

  // üß† ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Smart Delta Sync Mode
  enableSmartSync() {
    this.useSmartSync = true;
    console.log('üß† Smart Delta Sync Mode: ENABLED for all real-time sync jobs');
  }

  disableSmartSync() {
    this.useSmartSync = false;
    console.log('üìä Smart Delta Sync Mode: DISABLED - using standard incremental sync');
  }

  isSmartSyncEnabled(): boolean {
    return this.useSmartSync;
  }

  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ Smart Sync
  getSmartSyncStats() {
    return {
      smartSyncEnabled: this.useSmartSync,
      activeSyncJobs: this.syncJobs.size + this.pollingJobs.size,
      cronJobs: this.syncJobs.size,
      pollingJobs: this.pollingJobs.size
    };
  }

  // ‡∏´‡∏¢‡∏∏‡∏î sync job
  stopSyncJob(configId: number) {
    // ‡∏´‡∏¢‡∏∏‡∏î cron job
    const cronJob = this.syncJobs.get(configId);
    if (cronJob) {
      cronJob.stop();
      this.syncJobs.delete(configId);
      console.log(`Stopped cron sync job for config ${configId}`);
    }

    // ‡∏´‡∏¢‡∏∏‡∏î polling job
    const pollingJob = this.pollingJobs.get(configId);
    if (pollingJob) {
      clearInterval(pollingJob);
      this.pollingJobs.delete(configId);
      console.log(`Stopped polling sync job for config ${configId}`);
    }
  }

  // ‡∏´‡∏¢‡∏∏‡∏î sync jobs ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
  stopAllJobs() {
    // ‡∏´‡∏¢‡∏∏‡∏î cron jobs
    for (const [configId, job] of this.syncJobs) {
      job.stop();
    }
    this.syncJobs.clear();

    // ‡∏´‡∏¢‡∏∏‡∏î polling jobs
    for (const [configId, job] of this.pollingJobs) {
      clearInterval(job);
    }
    this.pollingJobs.clear();

    console.log('Stopped all sync jobs');
  }

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó sync job (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤)
  updateSyncJob(configId: number, interval?: string) {
    this.startSyncJob(configId, interval || '30s');
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ jobs ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
  getActiveJobs(): { cronJobs: number[], pollingJobs: number[] } {
    return {
      cronJobs: Array.from(this.syncJobs.keys()),
      pollingJobs: Array.from(this.pollingJobs.keys())
    };
  }

  // Manual sync ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏° sync ‡πÉ‡∏ô dashboard)
  async syncAll() {
    console.log('Manual sync all triggered');
    const configs = await syncService.getAllSyncConfigs();
    
    const results = await Promise.allSettled(
      configs.map(config => syncService.syncData(config.id))
    );

    let successCount = 0;
    let errorCount = 0;

    results.forEach((result, index) => {
      if (result.status === 'fulfilled' && result.value.success) {
        successCount++;
      } else {
        errorCount++;
        console.error(`Manual sync failed for config ${configs[index].id}:`, 
          result.status === 'rejected' ? result.reason : result.value.message);
      }
    });

    console.log(`Manual sync completed: ${successCount} success, ${errorCount} errors`);
    return { success: successCount, errors: errorCount, total: configs.length };
  }

  // ‡πÄ‡∏£‡∏¥‡πà‡∏° real-time sync ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö config ‡πÄ‡∏â‡∏û‡∏≤‡∏∞
  async startRealTimeSync(configId: number) {
    this.startSyncJob(configId, '10s'); // ‡∏ó‡∏∏‡∏Å 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö real-time
    return { success: true, message: `Real-time sync started for config ${configId}` };
  }

  // ‡∏´‡∏¢‡∏∏‡∏î real-time sync ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö config ‡πÄ‡∏â‡∏û‡∏≤‡∏∞
  async stopRealTimeSync(configId: number) {
    this.stopSyncJob(configId);
    return { success: true, message: `Real-time sync stopped for config ${configId}` };
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ real-time sync
  getRealTimeSyncStatus() {
    const activeJobs = this.getActiveJobs();
    return {
      isActive: activeJobs.cronJobs.length > 0 || activeJobs.pollingJobs.length > 0,
      totalJobs: activeJobs.cronJobs.length + activeJobs.pollingJobs.length,
      cronJobs: activeJobs.cronJobs,
      pollingJobs: activeJobs.pollingJobs,
      isInitialized: this.isInitialized
    };
  }
}

export default new RealTimeSyncManager();