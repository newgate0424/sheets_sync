// clean-null-rows.js - ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ NULL values ‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
require('dotenv').config({ path: '.env.local' });
const mysql = require('mysql2/promise');

async function cleanNullRows() {
  let connection;
  try {
    console.log('üîç Checking for NULL rows with tracking data...\n');

    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ database
    connection = await mysql.createConnection({
      host: process.env.DB_HOST || 'localhost',
      user: process.env.DB_USER || 'root',
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'sheets_sync'
    });

    // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ sync configs
    const [configs] = await connection.execute(`
      SELECT id, name, table_name, sheet_url, sheet_name, columns
      FROM sync_configs 
      WHERE is_active = 1
    `);

    for (const config of configs) {
      console.log(`üìã Checking Table: ${config.table_name}`);
      console.log(`üîó Config: ${config.name}`);

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö columns ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô table
      const [tableColumns] = await connection.execute(`
        SHOW COLUMNS FROM \`${config.table_name}\`
      `);

      // ‡πÅ‡∏¢‡∏Å data columns ‡∏à‡∏≤‡∏Å tracking columns
      const dataColumns = tableColumns
        .filter(col => !['id', 'sheet_row_index', 'row_hash', 'synced_at'].includes(col.Field))
        .map(col => col.Field);

      console.log(`üìä Data columns: ${dataColumns.join(', ')}`);

      // ‡∏´‡∏≤‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ NULL ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å data columns ‡πÅ‡∏ï‡πà‡∏°‡∏µ tracking data
      const nullConditions = dataColumns.map(col => `\`${col}\` IS NULL`).join(' AND ');
      
      const [nullRows] = await connection.execute(`
        SELECT id, sheet_row_index, row_hash, ${dataColumns.map(col => `\`${col}\``).join(', ')}
        FROM \`${config.table_name}\`
        WHERE (${nullConditions}) AND (sheet_row_index IS NOT NULL OR row_hash IS NOT NULL)
      `);

      console.log(`üîç Found ${nullRows.length} rows with NULL data but tracking columns`);

      if (nullRows.length > 0) {
        console.log('\n‚ö†Ô∏è  NULL rows found:');
        nullRows.forEach(row => {
          console.log(`   ID: ${row.id}, sheet_row_index: ${row.sheet_row_index}, row_hash: ${row.row_hash ? row.row_hash.substring(0, 8) + '...' : 'NULL'}`);
        });

        console.log(`\nüóëÔ∏è  Deleting ${nullRows.length} NULL rows...`);
        
        // ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ NULL ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å data columns
        const deleteResult = await connection.execute(`
          DELETE FROM \`${config.table_name}\`
          WHERE (${nullConditions}) AND (sheet_row_index IS NOT NULL OR row_hash IS NOT NULL)
        `);

        console.log(`‚úÖ Deleted ${deleteResult[0].affectedRows} NULL rows`);

        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡πÉ‡∏ô sync config
        const [remainingCount] = await connection.execute(`
          SELECT COUNT(*) as count FROM \`${config.table_name}\`
        `);
        const newCount = remainingCount[0].count;

        await connection.execute(`
          UPDATE sync_configs 
          SET row_count = ?, last_sync_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `, [newCount, config.id]);

        console.log(`üìä Updated row count to ${newCount}`);

        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å log
        await connection.execute(`
          INSERT INTO sync_logs (config_id, status, message, rows_synced)
          VALUES (?, 'success', ?, ?)
        `, [config.id, `Cleaned ${deleteResult[0].affectedRows} NULL rows`, deleteResult[0].affectedRows]);

      } else {
        console.log('‚úÖ No NULL rows found');
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
      const [finalCount] = await connection.execute(`
        SELECT COUNT(*) as count FROM \`${config.table_name}\`
      `);
      
      console.log(`\nüìä Final row count: ${finalCount[0].count}`);
      
      // ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
      const [finalData] = await connection.execute(`
        SELECT id, sheet_row_index, row_hash, ${dataColumns.map(col => `\`${col}\``).join(', ')}
        FROM \`${config.table_name}\`
        ORDER BY sheet_row_index
      `);

      console.log('\nüìÑ Remaining data:');
      console.log('   ID | sheet_row_index | Data columns');
      console.log('   ---|-----------------|-------------');
      finalData.forEach(row => {
        const dataValues = dataColumns.map(col => row[col] ? 'DATA' : 'NULL').join(',');
        console.log(`   ${row.id.toString().padStart(3)} | ${(row.sheet_row_index || 'NULL').toString().padStart(15)} | ${dataValues}`);
      });

      console.log('\n' + '='.repeat(80));
    }

    console.log('\nüéâ NULL row cleanup completed!');

  } catch (error) {
    console.error('‚ùå Error in cleanup:', error);
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ
cleanNullRows().catch(console.error);
